
  generalBlame(reason, accused) {
    var packet, ref;
    this.clearPackets();
    packet = Signed.create({
      packet: Packet.create({
        message: Message.create({
          blame: Blame.create({
            accused: VerificationKey.create({
              key: accused
            })
          })
        }),
        phase: Phase.values["BLAME"]
      })
    });
    if (ref = reason.toString(), indexOf.call(Object.keys(Reason.valuesById), ref) >= 0) {
      packet.packet.message.blame.reason = Reason.valuesById[reason.toString()];
    }
    return this.packets.packet.push(packet);
  }

  blameTheLiar(accused) {
    return this.generalBlame(Reason.values["LIAR"], accused);
  }

  blameInsufficientFunds(accused) {
    return this.generalBlame(Reason.values["INSUFFICIENTFUNDS"], accused);
  }

  blameEquivocationFailure(accused, invalidPackets = null) {
    this.generalBlame(Reason.values["EQUIVOCATIONFAILURE"], accused);
    if (invalidPackets) {
      return this.lastPacket().packet.message.blame.invalid = Invalid.create({
        invalid: invalidPackets
      });
    }
  }

  blameMissingOutputs(accused) {
    return this.generalBlame(Reason.values["MISSINGOUTPUT"], accused);
  }

  blameShuffleFailure(accused, hash) {
    this.generalBlame(Reason.values["SHUFFLEFAILURE"], accused);
    return this.lastPacket().packet.message.hash = Hash.create({
      hash: hash
    });
  }

  blameShuffleAndEquivocationFailure(accused, encryptionKey, decryptionKey, invalidPackets) {
    this.generalBlame(Reason.values["SHUFFLEANDEQUIVOCATIONFAILURE"], accused);
    this.lastPacket().packet.message.blame.invalid = Invalid.create({
      invalid: invalidPackets
    });
    return this.lastPacket().packet.message.blame.key = DecryptionKey.create({
      key: decryptionKey,
      public: encryptionKey
    });
  }

  blameInvalidSignature(accused) {
    return this.generalBlame(Reason.values["INVALIDSIGNATURE"], accused);
  }

  blameWrongTransactionSignature(accused) {
    return this.generalBlame(Reason.values["INVALIDSIGNATURE"], accused);
  }

  addEncryptionKey(ek, change) {
    var packet;
    packet = Signed.create({
      packet: Packet.create({
        message: Message.create({
          key: EncryptionKey.create({
            key: ek
          })
        })
      })
    });
    if (change) {
      packet.packet.message.address = Address.create({
        address: change
      });
    }
    return this.packets.packet.push(packet);
  }

  addInputs(inputsObject) {
    var key, packet, val;
    packet = Signed.create({
      packet: Packet.create({
        message: Message.create({
          inputs: {}
        })
      })
    });
    for (key in inputsObject) {
      val = inputsObject[key];
      packet.packet.message.inputs[key] = Coins.create({
        coins: val
      });
    }
    return this.packets.packet.push(packet);
  }

  addStr(str) {
    var packet;
    packet = Signed.create({
      packet: Packet.create({
        message: Message.create({
          str: str
        })
      })
    });
    return this.packets.packet.push(packet);
  }

  addHash(hash) {
    var packet;
    packet = Signed.create({
      packet: Packet.create({
        message: Message.create({
          hash: Hash.create({
            hash: hash
          })
        })
      })
    });
    return this.packets.packet.push(packet);
  }

  addSignatures(signatures) {
    var key, packet, val;
    packet = Signed.create({
      packet: Packet.create({
        message: Message.create({
          signatures: []
        })
      })
    });
    for (key in signatures) {
      val = signatures[key];
      packet.packet.message.signatures.push(Signature.create({
        utxo: key,
        signature: Signature.create({
          signature: val
        })
      }));
    }
    return this.packets.packet.push(packet);
  }

  getNewAddresses() {
    var k, len, packet, ref, results;
    ref = this.packets.packet;
    results = [];
    for (k = 0, len = ref.length; k < len; k++) {
      packet = ref[k];
      results.push(packet.packet.message.str);
    }
    return results;
  }

  getHashes() {
    var hashes, k, len, packet, ref;
    hashes = {};
    ref = this.packets.packet;
    for (k = 0, len = ref.length; k < len; k++) {
      packet = ref[k];
      hashes[packet.packet.fromKey.key] = packet.packet.message.hash.hash.toString('utf8');
    }
    return hashes;
  }

  getSignaturesAndPackets() {
    var k, len, packet, ref, results;
    ref = this.packets.packet;
    results = [];
    for (k = 0, len = ref.length; k < len; k++) {
      packet = ref[k];
      results.push([packet.signature.signature, Packet.encode(packet.packet).finish(), packet.packet.fromKey.key]);
    }
    return results;
  }
